'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateCommandsDocumentation = generateCommandsDocumentation;
exports.generateCommandDocumentation = generateCommandDocumentation;

var _padEnd = require('lodash/padEnd');

var _padEnd2 = _interopRequireDefault(_padEnd);

var _noSuchCommandText = require('./noSuchCommandText');

var _noSuchCommandText2 = _interopRequireDefault(_noSuchCommandText);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Generate documentation for all commands within a given group
 */
function generateCommandsDocumentation(commandGroups) {
  let group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

  const commandGroup = commandGroups[group];

  if (!commandGroup) {
    throw new Error((0, _noSuchCommandText2.default)(group));
  }

  // Find the maximum length of a command name, so we can pad the descriptions
  const cmdLength = commandGroup.reduce((max, cmd) => Math.max(cmd.name.length, max), 0);

  const rows = ['usage: sanity [-v|--version] [-d|--debug] [-h|--help] <command> [<args>]', '', 'Commands:'].concat(commandGroup.map(cmd => `   ${ (0, _padEnd2.default)(cmd.name, cmdLength) } ${ cmd.description }`)).concat(['', 'See \'sanity help <command>\' for specific information on a subcommand.']);

  return rows.join('\n');
}

/**
 * Generate documentation for a single command within the given group
 */
function generateCommandDocumentation(command, group, subCommand) {
  if (!command) {
    throw new Error(subCommand ? `"${ subCommand }" is not a subcommand of "${ group }". See 'sanity help ${ group }'` : (0, _noSuchCommandText2.default)(group));
  }

  const cmdParts = [group, subCommand].filter(Boolean).join(' ');
  return [`usage: sanity ${ cmdParts } ${ command.signature }`, '', `   ${ command.description }`, '', (command.helpText || '').trim()].join('\n');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2dlbmVyYXRlQ29tbWFuZHNEb2N1bWVudGF0aW9uLmpzIl0sIm5hbWVzIjpbImdlbmVyYXRlQ29tbWFuZHNEb2N1bWVudGF0aW9uIiwiZ2VuZXJhdGVDb21tYW5kRG9jdW1lbnRhdGlvbiIsImNvbW1hbmRHcm91cHMiLCJncm91cCIsImNvbW1hbmRHcm91cCIsIkVycm9yIiwiY21kTGVuZ3RoIiwicmVkdWNlIiwibWF4IiwiY21kIiwiTWF0aCIsIm5hbWUiLCJsZW5ndGgiLCJyb3dzIiwiY29uY2F0IiwibWFwIiwiZGVzY3JpcHRpb24iLCJqb2luIiwiY29tbWFuZCIsInN1YkNvbW1hbmQiLCJjbWRQYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJzaWduYXR1cmUiLCJoZWxwVGV4dCIsInRyaW0iXSwibWFwcGluZ3MiOiI7Ozs7O1FBTWdCQSw2QixHQUFBQSw2QjtRQTJCQUMsNEIsR0FBQUEsNEI7O0FBakNoQjs7OztBQUNBOzs7Ozs7QUFFQTs7O0FBR08sU0FBU0QsNkJBQVQsQ0FBdUNFLGFBQXZDLEVBQXlFO0FBQUEsTUFBbkJDLEtBQW1CLHVFQUFYLFNBQVc7O0FBQzlFLFFBQU1DLGVBQWVGLGNBQWNDLEtBQWQsQ0FBckI7O0FBRUEsTUFBSSxDQUFDQyxZQUFMLEVBQW1CO0FBQ2pCLFVBQU0sSUFBSUMsS0FBSixDQUFVLGlDQUFrQkYsS0FBbEIsQ0FBVixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFNRyxZQUFZRixhQUFhRyxNQUFiLENBQW9CLENBQUNDLEdBQUQsRUFBTUMsR0FBTixLQUFjQyxLQUFLRixHQUFMLENBQVNDLElBQUlFLElBQUosQ0FBU0MsTUFBbEIsRUFBMEJKLEdBQTFCLENBQWxDLEVBQWtFLENBQWxFLENBQWxCOztBQUVBLFFBQU1LLE9BQU8sQ0FDWCwwRUFEVyxFQUVYLEVBRlcsRUFHWCxXQUhXLEVBSVhDLE1BSlcsQ0FJSlYsYUFBYVcsR0FBYixDQUFpQk4sT0FDdkIsT0FBSyxzQkFBT0EsSUFBSUUsSUFBWCxFQUFpQkwsU0FBakIsQ0FBNEIsTUFBR0csSUFBSU8sV0FBWSxHQUQ5QyxDQUpJLEVBTVZGLE1BTlUsQ0FNSCxDQUNSLEVBRFEsRUFFUix5RUFGUSxDQU5HLENBQWI7O0FBV0EsU0FBT0QsS0FBS0ksSUFBTCxDQUFVLElBQVYsQ0FBUDtBQUNEOztBQUVEOzs7QUFHTyxTQUFTaEIsNEJBQVQsQ0FBc0NpQixPQUF0QyxFQUErQ2YsS0FBL0MsRUFBc0RnQixVQUF0RCxFQUFrRTtBQUN2RSxNQUFJLENBQUNELE9BQUwsRUFBYztBQUNaLFVBQU0sSUFBSWIsS0FBSixDQUFVYyxhQUNYLEtBQUdBLFVBQVcsK0JBQTRCaEIsS0FBTSx5QkFBc0JBLEtBQU0sSUFEakUsR0FFWixpQ0FBa0JBLEtBQWxCLENBRkUsQ0FBTjtBQUlEOztBQUVELFFBQU1pQixXQUFXLENBQUNqQixLQUFELEVBQVFnQixVQUFSLEVBQW9CRSxNQUFwQixDQUEyQkMsT0FBM0IsRUFBb0NMLElBQXBDLENBQXlDLEdBQXpDLENBQWpCO0FBQ0EsU0FBTyxDQUNKLGtCQUFnQkcsUUFBUyxNQUFHRixRQUFRSyxTQUFVLEdBRDFDLEVBRUwsRUFGSyxFQUdKLE9BQUtMLFFBQVFGLFdBQVksR0FIckIsRUFJTCxFQUpLLEVBS0wsQ0FBQ0UsUUFBUU0sUUFBUixJQUFvQixFQUFyQixFQUF5QkMsSUFBekIsRUFMSyxFQU1MUixJQU5LLENBTUEsSUFOQSxDQUFQO0FBT0QiLCJmaWxlIjoiZ2VuZXJhdGVDb21tYW5kc0RvY3VtZW50YXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGFkRW5kIGZyb20gJ2xvZGFzaC9wYWRFbmQnXG5pbXBvcnQgbm9TdWNoQ29tbWFuZFRleHQgZnJvbSAnLi9ub1N1Y2hDb21tYW5kVGV4dCdcblxuLyoqXG4gKiBHZW5lcmF0ZSBkb2N1bWVudGF0aW9uIGZvciBhbGwgY29tbWFuZHMgd2l0aGluIGEgZ2l2ZW4gZ3JvdXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ29tbWFuZHNEb2N1bWVudGF0aW9uKGNvbW1hbmRHcm91cHMsIGdyb3VwID0gJ2RlZmF1bHQnKSB7XG4gIGNvbnN0IGNvbW1hbmRHcm91cCA9IGNvbW1hbmRHcm91cHNbZ3JvdXBdXG5cbiAgaWYgKCFjb21tYW5kR3JvdXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Iobm9TdWNoQ29tbWFuZFRleHQoZ3JvdXApKVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbWF4aW11bSBsZW5ndGggb2YgYSBjb21tYW5kIG5hbWUsIHNvIHdlIGNhbiBwYWQgdGhlIGRlc2NyaXB0aW9uc1xuICBjb25zdCBjbWRMZW5ndGggPSBjb21tYW5kR3JvdXAucmVkdWNlKChtYXgsIGNtZCkgPT4gTWF0aC5tYXgoY21kLm5hbWUubGVuZ3RoLCBtYXgpLCAwKVxuXG4gIGNvbnN0IHJvd3MgPSBbXG4gICAgJ3VzYWdlOiBzYW5pdHkgWy12fC0tdmVyc2lvbl0gWy1kfC0tZGVidWddIFstaHwtLWhlbHBdIDxjb21tYW5kPiBbPGFyZ3M+XScsXG4gICAgJycsXG4gICAgJ0NvbW1hbmRzOicsXG4gIF0uY29uY2F0KGNvbW1hbmRHcm91cC5tYXAoY21kID0+XG4gICAgYCAgICR7cGFkRW5kKGNtZC5uYW1lLCBjbWRMZW5ndGgpfSAke2NtZC5kZXNjcmlwdGlvbn1gXG4gICkpLmNvbmNhdChbXG4gICAgJycsXG4gICAgJ1NlZSBcXCdzYW5pdHkgaGVscCA8Y29tbWFuZD5cXCcgZm9yIHNwZWNpZmljIGluZm9ybWF0aW9uIG9uIGEgc3ViY29tbWFuZC4nXG4gIF0pXG5cbiAgcmV0dXJuIHJvd3Muam9pbignXFxuJylcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBkb2N1bWVudGF0aW9uIGZvciBhIHNpbmdsZSBjb21tYW5kIHdpdGhpbiB0aGUgZ2l2ZW4gZ3JvdXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ29tbWFuZERvY3VtZW50YXRpb24oY29tbWFuZCwgZ3JvdXAsIHN1YkNvbW1hbmQpIHtcbiAgaWYgKCFjb21tYW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHN1YkNvbW1hbmRcbiAgICAgID8gYFwiJHtzdWJDb21tYW5kfVwiIGlzIG5vdCBhIHN1YmNvbW1hbmQgb2YgXCIke2dyb3VwfVwiLiBTZWUgJ3Nhbml0eSBoZWxwICR7Z3JvdXB9J2BcbiAgICAgIDogbm9TdWNoQ29tbWFuZFRleHQoZ3JvdXApXG4gICAgKVxuICB9XG5cbiAgY29uc3QgY21kUGFydHMgPSBbZ3JvdXAsIHN1YkNvbW1hbmRdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJylcbiAgcmV0dXJuIFtcbiAgICBgdXNhZ2U6IHNhbml0eSAke2NtZFBhcnRzfSAke2NvbW1hbmQuc2lnbmF0dXJlfWAsXG4gICAgJycsXG4gICAgYCAgICR7Y29tbWFuZC5kZXNjcmlwdGlvbn1gLFxuICAgICcnLFxuICAgIChjb21tYW5kLmhlbHBUZXh0IHx8ICcnKS50cmltKClcbiAgXS5qb2luKCdcXG4nKVxufVxuIl19