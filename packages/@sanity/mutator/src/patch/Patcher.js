// @flow
import parse from './parse'
import ImmutableAccessor from './ImmutableAccessor'
import {Ast, Matcher} from '../jsonpath'

export default class Patcher {
  patches : Array<Object>
  constructor(patch : Object) {
    this.patches = parse(patch)
  }
  apply(value : Object) {
    // Apply just makes a root accessor around the provided
    // value, then applies the patches. Due to the use of
    // ImmutableAccessor it is guaranteed to return either the
    // exact same object it was provided (in the case of no changes),
    // or a completely new object. It will never mutate the object in place.
    let result = value
    const accessor = new ImmutableAccessor(
      () => result,
      newValue => {
        result = newValue
      }
    )
    this.applyViaAccessor(accessor)
    return result
  }
  // If you want to use your own accessor implementation, you can use this method
  // to invoke the patcher. Since all subsequent accessors for children of this accessor
  // are obtained through the methods in the accessors, you retain full control of the
  // implementation throguhgout the application. Have a look in ImmutableAccessor to see
  // an example of how accessors are implemented.
  applyViaAccessor(accessor : Object) {
    this.patches.forEach(patch => {
      const matcher = Matcher.fromPath(patch.path).setPayload(patch)
      descend(matcher, accessor)
    })
  }
}

// Recursively (depth first) follows any leads generated by the matcher, expecting
// a patch to be the payload. When matchers report a delivery, the
// apply(targets, accessor) is called on the patch
function descend(matcher, accessor) {
  // Every time we execute the matcher a new set of leads is generated. Each lead
  // is a target (being an index, an attribute name or a range) in the form of an
  // Ast instance. For each lead target there is also a matcher. Our job is to obtain
  // accessor(s) for each target (there might be more than one, since the targets may
  // be ranges) and run the provided matcher on those accessors.
  const {leads, delivery} = matcher.match(accessor)
  leads.forEach(lead => {
    accessorsFromTarget(lead.target, accessor).forEach(childAccessor => {
      descend(lead.matcher, childAccessor)
    })
  })
  // Each time we run the matcher, we might also get a delivery. This means that a
  // term in the jsonpath terminated here and the patch should be applied. The delivery
  // arrives in the form of an array of targets and a payload (which in this application
  // is the patch). Conveniently the patches accept an array of targets and an accessor
  // to do its work, so here we just pass those to the patch and we're done.
  if (delivery) {
    const patch = delivery.payload
    patch.apply(delivery.targets, accessor)
  }
}

// Given a target and an accessor, genereates accessors for all child values
// in the provided accessor pointed to by the target. The target is either an
// index, an attribute name or a range
function accessorsFromTarget(target : Ast, accessor : ImmutableAccessor) {
  const result = []
  if (target.isIndexReference()) {
    target.toIndicies(accessor).forEach(i => {
      result.push(accessor.getIndex(i))
    })
  } else if (target.isAttributeReference()) {
    result.push(accessor.get(target.name()))
  } else {
    throw new Error(`Unable to derive accessor for target ${target.toString()}`)
  }
  return result
}
